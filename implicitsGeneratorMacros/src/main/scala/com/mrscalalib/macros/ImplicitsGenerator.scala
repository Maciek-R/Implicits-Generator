package com.mrscalalib.macros

import scala.annotation.{StaticAnnotation, compileTimeOnly}
import scala.collection.immutable.{AbstractSeq, LinearSeq}
import scala.language.experimental.macros
import scala.reflect.macros.whitebox

/** Purpose of this macro is to help with managing 'method too large error'.
  * Common problem in scala is that when using a lot of typeclasses on case classes with a lot of fields,
  * you can see 'method too large error'. Solution for this error is to write manually implicits to store intermediate results and
  * to tell compiler to not calculate everything at once.
  *
  * This macro should help with generating these intermediate implicits
  *
  * @param typeClassNames - list of Typeclass names for which implicits should be generated
  * @param imports - imports to tell compiler where to find for classes for which implicits should be generated
  *
  * Example:
  * {{{
  * object ImplicitsWrapperSupport {
  *  @generateAllImplicits(
  *    Seq("EncoderTypeClass", "DecoderTypeClass"),
  *    Seq("import com.macros.CaseClassInspector", "import com.macros.ImplicitsGeneratorDomainTest._") // Additional imports required for macro to find domain classes
  *  )
  *  val allNestedClasses: List[CaseClassDescription] =
  *    CaseClassInspector.findAllCaseClasses[TestWrapperClass] // macro to get all nested case class names
  *
  *  trait ImplicitsWrapper
  *    extends ImplicitsWrapperSupport.EncoderTypeClassImplicitsCache // these 2 traits were generated by @generateAllImplicits annotation
  *    with ImplicitsWrapperSupport.DecoderTypeClassImplicitsCache
  * }
  * }}}
  * If the domain looks like this:
  * {{{
  *  case class TestWrapperClass(testClass1: TestClass1, testClass2: Option[TestClass2])
  *  case class TestClass1(int: Int, List[TestClass3])
  *  case class TestClass2(str: String)
  *  case class TestClass3(a: String)
  * }}}
  * 'generateAllImplicits' macro should generate traits with intermediate implicits:
  * {{{
  * trait EncoderTypeClassImplicitsCache {
  *   implicit lazy val testWrapperClassEncoderTypeClass: EncoderTypeClass[TestWrapperClass] = shapeless.cachedImplicit
  *   implicit lazy val testClass1EncoderTypeClass: EncoderTypeClass[TestClass1] = shapeless.cachedImplicit
  *   implicit lazy val testClass2EncoderTypeClass: EncoderTypeClass[TestClass2] = shapeless.cachedImplicit
  *   implicit lazy val testClass3EncoderTypeClass: EncoderTypeClass[TestClass3] = shapeless.cachedImplicit
  * }
  * }}}
  */
@compileTimeOnly("enable macro paradise to expand macro annotations")
class generateAllImplicits(typeClassNames: Seq[String], imports: Seq[String]) extends StaticAnnotation {
  def macroTransform(annottees: Any*): Any = macro ImplicitsGenerator.impl
}

object ImplicitsGenerator {

  def impl(c: whitebox.Context)(annottees: c.Expr[Any]*): c.Expr[Any] = {
    import c.universe._

    def createImplicitVals(
        typeClassName: String,
        caseClassDescriptions: Seq[CaseClassDescription]
    ) = {
      caseClassDescriptions.map { caseClassDescription =>
        val implicitName =
          TermName(s"${caseClassDescription.fieldName}$typeClassName")
        val implicitTypeName = TypeName(caseClassDescription.fieldType)
        q"implicit lazy val $implicitName: ${TypeName(typeClassName)}[$implicitTypeName] = shapeless.cachedImplicit"
      }
    }

    def createTraitsWithImplicits(
        caseClassDescriptions: Seq[CaseClassDescription],
        typeClassNames: Seq[String]
    ): Seq[Tree] = {
      typeClassNames.map { typeClassName =>
        val implicitVals =
          createImplicitVals(typeClassName, caseClassDescriptions)
        val traitName = TypeName(s"${typeClassName}ImplicitsCache")
        q"trait $traitName {..$implicitVals}"
      }
    }

    val (typeClassNames, imports) = c.prefix.tree match {
      case q"new generateAllImplicits(..$values)" =>
        values match {
          case typeClassNames :: importsTree :: Nil =>
            val typeClasses = c.eval[Seq[String]](c.Expr(typeClassNames))
            val imports = c.eval[Seq[String]](c.Expr(importsTree))
            (typeClasses, imports)
          case _ =>
            c.abort(
              c.enclosingPosition,
              "'generateAllImplicits' macro takes 2 arguments of Seq[String] types"
            )
        }
      case _ => c.abort(c.enclosingPosition, "Macro not supported error")
    }

    val tree = annottees.map(_.tree).toList match {
      case declaration :: Nil =>
        val expression = declaration.children.last

        val importsTree = imports.map(c.parse(_))
        val caseClassDescriptionsTree =
          q"""
              ..$importsTree
              import com.macros.CaseClassDescription
              ..$expression
           """

        val caseClassDescriptions = c
          .eval[List[CaseClassDescription]](c.Expr(caseClassDescriptionsTree))
          .distinct

        val traits =
          createTraitsWithImplicits(caseClassDescriptions, typeClassNames)

        val allTraits = List(declaration) ++ traits
        q"..$allTraits"
      case _ =>
        c.abort(
          c.enclosingPosition,
          "generateImplicits macro can be applied only on val declaration"
        )
    }

    c.Expr(q"..$tree")
  }
}
